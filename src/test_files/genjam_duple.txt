extensions [ sound ]

globals [
 chromosomes ; list of all possible chromosomes
 random-who-list ; keeps a shuffled list for pretty-ness
 generations ; number of generations we've seen
 num-chromosomes
 shuffle-parts?
 sound?
 tempo-bpm
 hit-limit
 hit-density-modifier
 num-mutations
 mutation-strength
 soloer
 solo?
]

turtles-own [
  my-chromosomes ; list to hold the chromosomes of a drummer
  my-velocity ; the (int) velocity value of a drummer
  my-instrument ; the (string) instrument for that turtle
  mutation-rate ; variable to control "reproduction"
  hits ; counts the number of drum hits for a turtle across its lifespan
  hits-since-evolve ; the number of hits since a mutation or evolution
]

breed [ low-drums low-drummer ]
breed [ med-drums med-drummer ]
breed [ high-drums high-drummer ]

to setup
  clear-all
  ; Make the view big enough to show 16 rows (each a drummer) and however many 'beats'
  resize-world 0 ((num-chromosomes * 4) - 1) 0 15
  set-globals
  set-initial-turtle-variables
  reset-ticks
  update-view
end

; Procedure to play a pattern with evolution
to go
  ask turtles [ play ]
  ; If we've reached the end of a pattern, do some evolution!
  if (ticks mod (num-chromosomes * 4) = 0) and (ticks != 0) [
    set generations generations + 1
    go-evolve
  ]
  update-view
  tick
  wait 60 / tempo-bpm / 4   ; This roughly sets tempo
end

; Procedure to play a pattern without any evolution
to go-no-evolve
  ask turtles [ play ]
  update-view
  tick
  wait 60 / tempo-bpm / 4
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PLAY FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to play-my-drum ; turtle procedure
  let temp my-velocity
  if sound? [
    if solo? [ ; If you're a soloer, play out! Otherwise, be quiet!
      ifelse who = soloer [
        set temp my-velocity + 50
      ][
        set temp my-velocity - 50
      ]
   ]
    sound:play-drum my-instrument temp
  ]
end

to play ; turtle procedure
  if item (ticks mod (num-chromosomes * 4)) my-pattern = 1 [
    play-my-drum
    set hits hits + 1
    set hits-since-evolve hits-since-evolve + 1
  ]
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; END PLAY FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; EVOLUTION FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to go-evolve
  ; If there isn't a soloist, ask 2 of each type to evolve
  ifelse not solo? [
    ask n-of 2 low-drums [
      evolve
    ]
    ask n-of 2 med-drums [
      evolve
    ]
    ask n-of 2 high-drums [
      evolve
    ]
    ; If a drummer hasn't changed in a while, mutate
    ask turtles with [hits-since-evolve > hit-limit] [
      mutate
      set hits-since-evolve 0
    ]
  ][ ; If there is a soloist, do the same, but don't include the soloer
    ask n-of 2 low-drums with [ who != soloer ] [
      evolve
    ]
    ask n-of 2 med-drums with [ who != soloer ] [
      evolve
    ]
    ask n-of 2 high-drums with [ who != soloer ]  [
      evolve
    ]

    ; If a drummer hasn't changed in a while, mutate
    ask turtles with [ hits-since-evolve > hit-limit and who != soloer ] [
      mutate
      set hits-since-evolve 0
    ]
  ]
end

to evolve ; turtle procedure
  let mate nobody
  let list-of-fitnesses []
  let search-fitness 0

  if is-low-drummer? self [
    set list-of-fitnesses [ fitness ] of other breed
    set search-fitness select-random-weighted-fitness list-of-fitnesses
    set mate one-of other breed with [ fitness = search-fitness ]
  ]

  if is-med-drummer? self [
    set list-of-fitnesses [ fitness ] of turtles with [ breed != [ breed ] of myself ]
    set search-fitness select-random-weighted-fitness list-of-fitnesses
    set mate one-of turtles with [ (breed != [breed] of myself) and (fitness = search-fitness)]
  ]

  if is-high-drummer? self [
    set list-of-fitnesses [fitness] of other breed
    set search-fitness select-random-weighted-fitness list-of-fitnesses
    set mate one-of other breed with [fitness = search-fitness]
  ]

  let offspring-chromosomes reproduce-with mate

  ask min-one-of other breed with [who != soloer] [fitness] [
    set my-chromosomes offspring-chromosomes
    set hits-since-evolve 0
  ]
end

; This is where the basic genetic algorithm comes in
to-report reproduce-with [ mate ] ; turtle procedure
  ; The asker is 1st Parent while mate is 2nd parent
  let her-chromosomes [ my-chromosomes ] of mate

  ; Pick a random cross-over point
  let crossover-point random length my-chromosomes

  ; Combine the chromosomes
  let baby-chromosomes sentence (sublist my-chromosomes 0 crossover-point) (sublist her-chromosomes crossover-point length her-chromosomes)

  ; Do a little mutation
  let mutation-chance 0
  if is-low-drummer? self [
    set mutation-chance 50
  ]
  if is-med-drummer? self [
    set mutation-chance 25
  ]
  if is-high-drummer? self [
    set mutation-chance 10
  ]

  ; Maybe actually mutate
  if random 100 > mutation-chance [
    set baby-chromosomes mutate-chromosomes baby-chromosomes
  ]
  report baby-chromosomes
end


; FITNESS FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
; Dependent on breed, because you can lose fitness or gain fitness by fitting to your particular proclivities
to-report fitness ; turtle procedure
  ; Arbitrary 10% window around target density
  let my-fitness 0

  ; Want to be under the hit-density and be on the downbeats
  if is-low-drummer? self [
    set my-fitness downbeat-fitness
    if my-density-fitness > (hit-density-modifier - 0.1) [
      set my-fitness my-fitness / 1.5
    ]
  ]

  ; Want to be at the hit-density and be on the off-beats
  if is-med-drummer? self [
    set my-fitness offbeat-fitness
    if (my-density-fitness < hit-density-modifier - 0.1) or (my-density-fitness > hit-density-modifier + 0.1) [
      set my-fitness my-fitness / 2
    ]
  ]

  ; Want to be above the hit-density and have lots o' clusters
  if is-high-drummer? self [
    set my-fitness offbeat-fitness
    if my-density-fitness < hit-density-modifier + 0.1 [
      set my-fitness my-fitness / 2
    ]
  ]
  ; use add 1 smoothing
  report my-fitness + 1
end

to-report my-density-fitness ; turtle procedure
  report sum my-pattern / length my-pattern
end

to-report cluster-fitness ; turtle procedure
  ; window size at 3
  let i 4
  let cluster-count 0
  while [i <= length my-pattern] [
    if (sum sublist my-pattern (i - 4) i) = 3 [
      set cluster-count cluster-count + 1
    ]
  ]
  ; Lots of clusters relative to the notes I play
  report cluster-count / sum my-pattern * 100
end

to-report offbeat-fitness ; turtle procedure
  let offbeat-count 0
  foreach range length my-pattern [ i ->
    if i mod 2 != 0 [
      if item i my-pattern = 1 [
        set offbeat-count offbeat-count + 1
      ]
    ]
  ]
  if offbeat-count = 0 [ report 0 ]
  ; You want more off-beats and less down-beats
  report offbeat-count / sum my-pattern * 100
end

to-report downbeat-fitness ; turtle procedure
  let downbeat-count 0
  foreach range length my-pattern [ i ->
    if i mod 2 = 0 [
      if item i my-pattern = 1 [
        set downbeat-count downbeat-count + 1
      ]
    ]
  ]

  if downbeat-count = 0 [ report 0 ]
  ; In other words, you want lots of downbeats in comparison to your other notes
  report downbeat-count / sum my-pattern * 100
end

to mutate ; turtle procedure
  set my-chromosomes mutate-chromosomes my-chromosomes
end

; Procedure to mutate a chromosome
to-report mutate-chromosomes [the-chromosomes]
  ; basically picks a chromosome, mutates it, returns a new set
  let new-chromosomes the-chromosomes
  repeat num-mutations [
    let temp random num-chromosomes
    set new-chromosomes replace-item temp new-chromosomes ((round (random-normal (item temp new-chromosomes) mutation-strength)) mod 16)
  ]
  report new-chromosomes
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; END EVOLUTION FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HELPER FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Converts a set of chromosomes into a binary rhythm pattern
to-report my-pattern ; turtle Procedure
  let pattern []
  foreach my-chromosomes [ n ->
   set pattern sentence pattern (get-chromosome n)
  ]
  report pattern
end

to set-globals
  set generations 0
  set random-who-list range 16
  ; this is just for looks. we keep a map of who to random-who
  if shuffle-parts? [
    set random-who-list shuffle random-who-list
    set random-who-list shuffle random-who-list
  ]
  set chromosomes []
  ; CHROMOSOME LIBRARY
  let c0 [0 0 0 0]
  let c1 [1 0 0 0]  let c2  [0 1 0 0] let c3 [0 0 1 0] let c4 [0 0 0 1]
  let c5 [1 1 0 0]  let c6  [1 0 1 0] let c7 [1 0 0 1] let c8 [0 1 1 0]
  let c9 [0 1 0 1]  let c10 [0 0 1 1]
  let c11 [1 1 1 0] let c12 [1 0 1 1] let c13 [1 1 0 1] let c14 [0 1 1 1]
  let c15 [1 1 1 1]
  set chromosomes (list c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 c10 c11 c12 c13 c14 c15)
end

to set-initial-turtle-variables
  create-low-drums 6 [
    set my-instrument "Acoustic Bass Drum"
    set my-velocity 50
    set color red
    set mutation-rate 64
  ]

  create-med-drums 5 [
    set my-instrument "Acoustic Snare"
    set color green
    set my-velocity 50
    set mutation-rate 32
  ]

  create-high-drums 5 [
    set my-instrument "Closed Hi Hat"
    set color blue
    set my-velocity 100
    set mutation-rate 16
  ]

  ask turtles [
    set my-chromosomes (n-values num-chromosomes [ 1 ])
    hide-turtle
    set hits 0
  ]
end

; Procedure to update the view (simplified music notation)
to update-view
  ask turtles [
    let column 0
    let row item who random-who-list
    foreach my-pattern [ n ->
      ifelse n = 1 [
        ifelse solo? and (soloer = who) [
          ask patch column row [ set pcolor white ]
        ][
          ask patch column row [ set pcolor [ color ] of myself ]
        ]
      ][
        ask patch column row [ set pcolor black ]
      ]
      set column column + 1
    ]
  ]
  ; color the patches that are currently being played
  ask patches with [ pxcor = (ticks mod (num-chromosomes * 4)) ] [ set pcolor yellow ]
end

; Procedure to get a chromosomes pattern from the library
to-report get-chromosome [ index ]
  report item index chromosomes
end

; This is my version of picking a weighted random turtle
to-report select-random-weighted-fitness [ the-list ]
  let weighted-list []
  foreach the-list [ x ->
    ; add one smoothing
    foreach range round ((x / sum the-list * 100) + 1) [
      set weighted-list fput x weighted-list
    ]
  ]
  report item (random length weighted-list) weighted-list
end


; Copyright 2017 Uri Wilensky.
; See Info tab for full copyright and license.